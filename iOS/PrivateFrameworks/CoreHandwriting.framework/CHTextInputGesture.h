/* Generated by RuntimeBrowser
   Image: /System/Library/PrivateFrameworks/CoreHandwriting.framework/CoreHandwriting
 */

@interface CHTextInputGesture : NSObject {
    struct _NSRange { 
        unsigned long long location; 
        unsigned long long length; 
    }  __storedAffectedRange;
    CHTokenizedTextResult * __textResult;
    long long  _gestureType;
    <CHStroke> * _lastStroke;
    NSLocale * _locale;
    CHDrawing * _normalizedDrawing;
    CHDrawing * _originalDrawing;
    bool  _preferCharacterLevel;
    CHTextInputTargetContentInfo * _targetContentInfo;
}

@property (nonatomic) struct _NSRange { unsigned long long x1; unsigned long long x2; } _storedAffectedRange;
@property (nonatomic, retain) CHTokenizedTextResult *_textResult;
@property (nonatomic) long long gestureType;
@property (nonatomic, readonly) <CHStroke> *lastStroke;
@property (nonatomic, readonly) NSLocale *locale;
@property (nonatomic, readonly) CHDrawing *normalizedDrawing;
@property (nonatomic, readonly) CHDrawing *originalDrawing;
@property (nonatomic, readonly) bool preferCharacterLevel;
@property (nonatomic, readonly) CHTextInputTargetContentInfo *targetContentInfo;

+ (struct _NSRange { unsigned long long x1; unsigned long long x2; })_affectedRangeByRefiningShapeBasedGesture:(struct _NSRange { unsigned long long x1; unsigned long long x2; })arg1 resultType:(long long)arg2 drawing:(id)arg3 targetContentInfo:(id)arg4;
+ (long long)_cursorPositionForPoint:(struct CGPoint { double x1; double x2; })arg1 referenceString:(id)arg2 referenceCharRects:(struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; }*)arg3 searchingRange:(struct _NSRange { unsigned long long x1; unsigned long long x2; })arg4;
+ (bool)_isShapeBasedRangeRefinementSupportedForResultType:(long long)arg1;
+ (void)_shouldExpandToFullTokensForScriptInString:(id)arg1 withRange:(struct _NSRange { unsigned long long x1; unsigned long long x2; })arg2 shouldExpandStart:(bool*)arg3 shouldExpandEnd:(bool*)arg4;
+ (bool)isDrawingCenterOnBlank:(id)arg1 targetContentInfo:(id)arg2 insertionLocation:(long long*)arg3;
+ (bool)isEditGestureForDrawing:(id)arg1 targetContentInfo:(id)arg2 tentativeResultType:(long long)arg3;
+ (bool)isVerticalBarShapeFromLineResult:(id)arg1 originalDrawing:(id)arg2 isDirectionDownward:(bool*)arg3;
+ (struct _NSRange { unsigned long long x1; unsigned long long x2; })rangeOfTokenAtCharacterIndex:(long long)arg1 inString:(id)arg2 locale:(id)arg3;
+ (bool)shouldReclassifyGestureType:(long long)arg1;
+ (id)verticalBarGestureFromLineResult:(id)arg1 currentGesture:(id)arg2;

- (struct _NSRange { unsigned long long x1; unsigned long long x2; })_affectedRangeByAdjustingForProtectedCharacters:(struct _NSRange { unsigned long long x1; unsigned long long x2; })arg1;
- (struct _NSRange { unsigned long long x1; unsigned long long x2; })_affectedRangeByAdjustingToTokensIfNeeded:(struct _NSRange { unsigned long long x1; unsigned long long x2; })arg1 allowSubtoken:(bool)arg2 didExpand:(bool*)arg3;
- (struct _NSRange { unsigned long long x1; unsigned long long x2; })_affectedRangeByRemovingTerminatingNewLines:(struct _NSRange { unsigned long long x1; unsigned long long x2; })arg1;
- (struct _NSRange { unsigned long long x1; unsigned long long x2; })_affectedRangeByTrimmingSpaces:(struct _NSRange { unsigned long long x1; unsigned long long x2; })arg1;
- (struct _NSRange { unsigned long long x1; unsigned long long x2; })_storedAffectedRange;
- (id)_textResult;
- (void)dealloc;
- (long long)gestureType;
- (void)getAffectedRange:(struct _NSRange { unsigned long long x1; unsigned long long x2; }*)arg1 expandedToFullTokens:(bool*)arg2;
- (id)initWithGestureType:(long long)arg1 targetContentInfo:(id)arg2 locale:(id)arg3 normalizedDrawing:(id)arg4 originalDrawing:(id)arg5 lastStroke:(id)arg6 preferCharacterLevel:(bool)arg7;
- (id)lastStroke;
- (id)locale;
- (id)normalizedDrawing;
- (id)originalDrawing;
- (bool)preferCharacterLevel;
- (void)setGestureType:(long long)arg1;
- (void)set_storedAffectedRange:(struct _NSRange { unsigned long long x1; unsigned long long x2; })arg1;
- (void)set_textResult:(id)arg1;
- (id)targetContentInfo;
- (id)textResult;

@end
